<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../../../../misc/Meta.xsl" ?>

<Model
 name="olap"
 dtdName="olap.dtd"
 className="OlapModelDef"
 packageName="com.flywet.platform.olap.model"
 importName="com.flywet.platform.olap.sql.SqlQuery"
 root="Schema"
 version="1.0">
    <Doc>
这是OLAP的XML模型文件
<p/>
版本：$Id$
    </Doc>

    <!-- Schema ========================================================== -->
    <Element type="Schema">
        <Doc>
            <p>Schema是立方体(cubes)和虚拟立方体(virtual cubes)的集合,
            也包含了用于立方体(cubes)的共享维度(shared dimensions)、
            命名集(named sets)、角色(roles)、用户自定义函数的声明。</p>
        </Doc>
        <Attribute name="name" required="true">
            <Doc>Schema名字</Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>Schema描述</Doc>
        </Attribute>
        <Attribute name="measuresCaption" required="false">
            <Doc>
                度量维度的标示
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Array name="parameters" type="Parameter">
            <Doc>
                Schema的参数定义集合
            </Doc>
        </Array>
        <Array name="dimensions" type="Dimension">
            <Doc>
                共享维度(Shared dimensions)集合
            </Doc>
        </Array>
        <Array name="cubes" type="Cube">
            <Doc>
                立方体(Cubes)集合
            </Doc>
        </Array>
        <Array name="virtualCubes" type="VirtualCube">
            <Doc>
                虚拟立方体(Virtual cubes)集合
            </Doc>
        </Array>
        <Array name="namedSets" type="NamedSet">
            <Doc>
                命名集(Named sets)
            </Doc>
        </Array>
        <Array name="userDefinedFunctions" type="UserDefinedFunction">
            <Doc>
                用户自定义函数声明集合
            </Doc>
        </Array>
        <Code><![CDATA[
            Cube getCube(String cubeName) {
                for (int i = 0; i < cubes.length; i++) {
                    if (cubes[i].name.equals(cubeName)) {
                        return cubes[i];
                    }
                }
                throw Util.newInternal("Cannot find cube '" + cubeName + "'");
            }
            Dimension getPublicDimension(String dimensionName) {
                for (int i = 0; i < dimensions.length; i++) {
                    if (dimensions[i].name.equals(dimensionName)) {
                        return dimensions[i];
                    }
                }
                throw Util.newInternal(
                    "Cannot find public dimension '" + dimensionName + "'");
            }]]>
        </Code>
    </Element>

    <!-- 立方体维度 CubeDimension ==================================================== -->
    <Element type="CubeDimension" abstract="true">
        <Doc>
            立方体维度(CubeDimension),可用于维度（MSOLAP称为“共享维度(shared dimension)”）,
            或者用于私有维度(private dimension)
        </Doc>
        <Attribute name="name" required="true"/>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                维度描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="foreignKey">
            <Doc>
                事实表中连接到该维度末级的列的名称。
                要求必须是私有维度(private Dimension)或者维度引用(DimensionUsage),
                但不能是公共维度(public Dimension)
            </Doc>
        </Attribute>
        <Attribute name="highCardinality" type="Boolean" default="false">
            <Doc>
                标识其为高基数维度，即该维度包含未定义的和大量的值，
                如果该属性设为true时，对整个维度数据全覆盖的活动将不会执行，
                同时避免使用缓存
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Code><![CDATA[
            /**
             * 查找该维度的基础维度。
             * 如果该维度是一个共享维度，则返回引用的维度，否则返回维度本身。
             *
             * <p>该方法不会返回null，如果维度找不到，会抛出异常</p>
             *
             * @param schema Schema, never null
             * @pre schema != null
             * @post return != null
             */
            public abstract Dimension getDimension(Schema schema);]]>
        </Code>
    </Element>

    <!-- 立方体 Cube ============================================================ -->
    <Element type="Cube">
        <Doc>
            立方体定义
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                立方体名称
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                立方体描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="defaultMeasure" required="false">
            <Doc>
                立方体的默认度量名称
            </Doc>
        </Attribute>
        <Attribute name="cache" type="Boolean" default="true">
            <Doc>
                标识该立方体的事实表数据是否被缓冲，
                默认缓存数据
            </Doc>
        </Attribute>
        <Attribute name="enabled" type="Boolean"
                    required="false" default="true">
            <Doc>
                是否可用，如果为false，将被忽略
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Object name="fact" type="Relation" required="true">
            <Doc>
                事实表名称，该表是所有度量的来源。
            </Doc>
        </Object>
        <Array name="dimensions" type="CubeDimension">
        	<Doc>
        		维度集合
        	</Doc>
        </Array>
        <Array name="measures" type="Measure">
        	<Doc>
        		度量集合
        	</Doc>
        </Array>
        <Array name="calculatedMembers" type="CalculatedMember">
            <Doc>
               	计算维度集合
            </Doc>
        </Array>
        <Array name="namedSets" type="NamedSet">
            <Doc>
                命名集合
            </Doc>
        </Array>
        <Code><![CDATA[
            public boolean isEnabled() {
                return enabled.booleanValue();
            }
            Dimension getDimension(Schema xmlSchema, String dimensionName) {
                for (int i = 0; i < dimensions.length; i++) {
                    if (dimensions[i].name.equals(dimensionName)) {
                        return dimensions[i].getDimension(xmlSchema);
                    }
                }
                throw Util.newInternal(
                    "Cannot find dimension '" + dimensionName + "' in cube '" +
                    name + "'");
            }
            ]]>
        </Code>
    </Element>

    <!-- 虚拟立方体 VirtualCube ====================================================== -->
    <Element type="VirtualCube">
        <Doc>
            虚拟立方体的维度和度量是从其他立方体中收集起来的
        </Doc>
        <Attribute name="enabled" type="Boolean"
                    required="false" default="true">
            <Doc>
                是否可用，如果为false，将被忽略
            </Doc>
        </Attribute>
        <Attribute name="name"><Doc></Doc></Attribute>
        <Attribute name="defaultMeasure" required="false">
            <Doc>
            	立方体的默认度量
            </Doc>
         </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                虚拟立方体描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Object name="cubeUsage" type="CubeUsages"><Doc></Doc></Object>
        <Array name="dimensions" type="VirtualCubeDimension"><Doc></Doc></Array>
        <Array name="measures" type="VirtualCubeMeasure"><Doc></Doc></Array>
        <Array name="calculatedMembers" type="CalculatedMember">
            <Doc>
                该虚拟立方体的计算成员。
                从其他立方体中继承过来的计算成员不在此处。
            </Doc>
        </Array>
        <Array name="namedSets" type="NamedSet">
            <Doc>
                命名集合
            </Doc>
        </Array>
        <Code><![CDATA[
            public boolean isEnabled() {
                return enabled.booleanValue();
            }]]>
        </Code>
    </Element>

    <!-- 立方体引用集合 CubeUsages ============================================= -->
    <Element type="CubeUsages">
        <Doc>
            虚拟立方体引入的其他立方体集合
        </Doc>
        <Array name="cubeUsages" type="CubeUsage" min="1"><Doc></Doc></Array>
    </Element>

    <!-- 立方体引用 CubeUsage ============================================= -->
    <Element type="CubeUsage">
        <Attribute name="cubeName" required="true">
            <Doc>
                虚拟立方体使用的立方体名称
            </Doc>
        </Attribute>
        <Attribute name="ignoreUnrelatedDimensions" type="Boolean" default="false">
            <Doc>
                如果为true，表示将该立方体中与度量不相干的维度推到最上层显示
            </Doc>
        </Attribute>
    </Element>

    <!-- 虚拟立方体维度 VirtualCubeDimension ============================================= -->
    <Element type="VirtualCubeDimension" class="CubeDimension">
        <Doc>
            虚拟立方体维度(VirtualCubeDimension)表示一个虚拟立方体的维度
        </Doc>
        <Attribute name="cubeName">
            <Doc>
                维度来自哪个立方体，如果该维度是共享维度可以不进行指定
            </Doc>
        </Attribute>
        <Attribute name="name">
            <Doc>
                维度名称
            </Doc>
        </Attribute>
        <Code><![CDATA[
            // implement CubeDimension
            public Dimension getDimension(Schema schema) {
                Util.assertPrecondition(schema != null, "schema != null");
                if (cubeName == null) {
                    return schema.getPublicDimension(name);
                } else {
                    Cube cube = schema.getCube(cubeName);
                    return cube.getDimension(schema, name);
                }
            }]]>
        </Code>
    </Element>

    <!-- 虚拟立方体度量 VirtualCubeMeasure =============================================== -->
    <Element type="VirtualCubeMeasure">
        <Doc>
            虚拟立方体度量(VirtualCubeMeasure)表示一个虚拟立方体的度量
        </Doc>
        <Attribute name="cubeName">
            <Doc>
                度量来自哪个立方体
            </Doc>
        </Attribute>
        <Attribute name="name">
            <Doc>
                度量名称
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean" required="false">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
    </Element>

    <!-- 维度引用 DimensionUsage =================================================== -->
    <Element type="DimensionUsage" class="CubeDimension">
        <Doc>
            共享维度的引用，在立方体的上下文中存在
        </Doc>
        <Attribute name="source" required="true">
            <Doc>
            	来源维度名称，必须来自该schema，忽略大小写
            </Doc>
        </Attribute>
        <Attribute name="level" required="false">
            <Doc>
                连接级别，如果未指定，连接维度的最低级别
            </Doc>
        </Attribute>
        <Attribute name="usagePrefix" required="false">
            <Doc>
                如果存在，在维度聚合树型合起来时作为维度列的名称显示。
                1）在聚合时，对不同维度起到消除歧义的作用
                2）多个共享维度有同一个列名
            </Doc>
        </Attribute>
        <Code><![CDATA[
            // implement CubeDimension
            public Dimension getDimension(Schema schema) {
                Util.assertPrecondition(schema != null, "schema != null");
                for (int i = 0; i < schema.dimensions.length; i++) {
                    if (schema.dimensions[i].name.equals(source)) {
                        return schema.dimensions[i];
                    }
                }
                throw Util.newInternal(
                    "Cannot find shared dimension '" + source + "'");
            }]]>
        </Code>
    </Element>

    <!-- Dimension ======================================================== -->
    <Element type="Dimension" class="CubeDimension">
        <Doc>
            维度是一个层次结构，分为两类：
            <dfn>公共维度</dfn>，属于Schema，可以用于多个立方体；
            <dfn>私有</dfn>维度，属于Cube。
            <code>foreignKey</code>属性只用于私有维度
        </Doc>
        <Attribute name="name" required="true"><Doc></Doc></Attribute>
        <Attribute name="type" required="false">
            <Doc>
                维度类型有，“标准维度”、“时间维度”
                <dfn>时间</dfn>维度，可以使用MDX的时间函数(WTD,YTD,QTD等)。
                默认是标准维度
            </Doc>
            <Value>StandardDimension</Value>
            <Value>TimeDimension</Value>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                维度描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="usagePrefix" required="false">
            <Doc>
                如果存在，在维度聚合树型合起来时作为维度列的名称显示。
                1）在聚合时，对不同维度起到消除歧义的作用
                2）多个共享维度有同一个列名
                只能用于私有维度
            </Doc>
        </Attribute>

        <Array name="hierarchies" type="Hierarchy"><Doc></Doc></Array>
        <Code>
            // implement CubeDimension
            public Dimension getDimension(Schema schema) {
                Util.assertPrecondition(schema != null, "schema != null");
                return this;
            }

            // Return the dimension's enumerated type.
            public DimensionType getDimensionType() {
                if (type == null) {
                    return null; //DimensionType.StandardDimension;
                } else {
                    return DimensionType.valueOf(type);
                }
            }
        </Code>
    </Element>

    <Element type="Hierarchy">
        <Doc>
            层次结构定义
            
            <p/>至少要指定一个<code>&lt;Relation&gt;</code> 
            或者 <code>memberReaderClass</code>。
            如果没有指定，该层次结构假定来自当前立方体的同一个事实表
        </Doc>
        <Attribute name="name" required="false">
            <Doc>
                层次结构名称，如果未指定，默认为其维度的名称
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Attribute name="hasAll" type="Boolean" required="true">
            <Doc>
                层次结构是否包含一个叫做“全部(All)”的成员
            </Doc>
        </Attribute>
        <Attribute name="allMemberName" required="false">
            <Doc>
                用于“全部(All)”的成员的显示名称，此项非必选项，
                默认全部成员显示为'All <i>hierarchyName</i>'，例如，'All Store'
            </Doc>
        </Attribute>
        <Attribute name="allMemberCaption" required="false">
            <Doc>
                用来替换allMemberName属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="allLevelName" required="false">
            <Doc>
                “全部(all)”层级的名称，此项非必选项，
                默认显示'(All)'
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="primaryKey">
            <Doc>
                The name of the column which identifies members, and
                which is referenced by rows in the fact table.
                If not specified, the key of the lowest level is used.
                See also <code>CubeDimension.foreignKey</code>.
                
            </Doc>
        </Attribute>
        <Attribute name="primaryKeyTable">
            <Doc>
                The name of the table which contains <code>primaryKey</code>.
                If the hierarchy has only one table, defaults to that;
                it is required.
            </Doc>
        </Attribute>
        <Attribute name="defaultMember"><Doc></Doc></Attribute>
        <Attribute name="memberReaderClass">
            <Doc>
                自定义成员读取类，
                实现rolap.MemberReader接口
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                层级结构描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="uniqueKeyLevelName" required="false">
            <Doc>
		        Should be set to the level (if such a level exists) at which depth it is known
		        that all members have entirely unique rows, allowing SQL GROUP BY clauses to
                be completely eliminated from the query.
            </Doc>
        </Attribute>

        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Object name="relation" type="RelationOrJoin">
            <Doc>
                {@link Table 数据表},
                {@link Join 数据表集合},
                {@link View SQL statement}, 
                {@link InlineTable 内敛表}
                该层次结构依赖关系
            </Doc>
        </Object>
        <Array name="levels" type="Level"><Doc></Doc></Array>
        <Array name="memberReaderParameters" type="MemberReaderParameter"/>
    </Element>

    <Element type="Level">
        <Attribute name="approxRowCount" required="false">
            <Doc>
                该层级的成员评估数
                设置该属性有助于提升请求效率
                MDSCHEMA_LEVELS, MDSCHEMA_HIERARCHIES and
                MDSCHEMA_DIMENSIONS XMLA 
            </Doc>
        </Attribute>
        <Attribute name="name" required="true"><Doc></Doc></Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                是否可见，默认true
            </Doc>
        </Attribute>
        <Attribute name="table" required="false">
            <Doc>
                层级来源表，
                如果来自与同一个表，默认使用层次结构的表名
                否则，必选指定此选项
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="column">
            <Doc>
                该层级唯一标识值对应的列名
            </Doc>
        </Attribute>
        <Attribute name="nameColumn">
            <Doc>
                该层级用于显示的名称的列名
            </Doc>
        </Attribute>

        <Attribute name="ordinalColumn" required="false">
            <Doc>
                成员排序标识的列名。
                如果没有指定，则按照关键字列进行排序
            </Doc>
        </Attribute>
        <Attribute name="parentColumn" required="false">
            <Doc>
                父子层级，父成员的列名
            </Doc>
        </Attribute>
        <Attribute name="nullParentValue" required="false">
            <Doc>
                对于父子层级，用于标识父为空的值，典型的值有'NULL'和'0'
            </Doc>
        </Attribute>
        <Attribute name="type" default="String">
            <Doc>
                标识层级关键字列的类型
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.
				在生成SQL语句是，对于String类型类名会用引号扩住，
				对于Integer和Numeric类型则不使用
				Date, Time, Timestamp类型根据SQL方言进行处理
				作为SQL兼容方言，在值前面显示添加类型名称，例如，"DATE '2006-06-01'"
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="internalType" required="false">
            <Doc>
            	用于存储该层级关键字列的Java类型。
            	这也取决于调用检索列的JDBC方法，例如，如果Java类型设置为int，
            	那么程序会使用'ResultSet.getInt(int)'获取值。
            	
            	<p/>通常情况下，不用设置这个属性，原因是程序会根据数据库中列的类型智能判断类型。

                <p/>允许的值有: 'int', 'long', 'Object', 'String'.
            </Doc>
            <Value>int</Value>
            <Value>long</Value>
            <Value>Object</Value>
            <Value>String</Value>
        </Attribute>
        <Attribute name="uniqueMembers" type="Boolean" default="false">
            <Doc>
                是否成员在所有的父成员下面是唯一的。
                例如，邮编在全国范围是唯一的，那么它的一级成员也总是唯一的。
            </Doc>
        </Attribute>
        <Attribute name="levelType" required="false" default="Regular">
            <Doc>
                该层级是一个正则类型，或者时间相关类型
                该值有别于时间相关函数，例如，YTD(year-to-date)
            </Doc>
            <Value>Regular</Value>
            <Value>TimeYears</Value>
            <Value>TimeHalfYears</Value>
            <Value>TimeHalfYear</Value>
            <Value>TimeQuarters</Value>
            <Value>TimeMonths</Value>
            <Value>TimeWeeks</Value>
            <Value>TimeDays</Value>
            <Value>TimeHours</Value>
            <Value>TimeMinutes</Value>
            <Value>TimeSeconds</Value>
            <Value>TimeUndefined</Value>
        </Attribute>
        <Attribute name="hideMemberIf" default="Never">
            <Doc>
            	通过条件决定该层级的哪个成员隐藏。
            	如果一个层次结构有一个或多个级别有隐藏成员，
            	那么可能不是所有的叶子成员离根节点距离相同，
            	这将成为<dfn>不规则</dfn>层级结构

                <p>允许的值有：
                <code>Never</code> 成员总是显示，默认
                <code>IfBlankName</code> 如果成员为null，空值，全是空格，则不显示
                <code>IfParentsName</code> 除非它的名字匹配它的父的名字，都将显示
                </p>
            </Doc>
            <Value>Never</Value>
            <Value>IfBlankName</Value>
            <Value>IfParentsName</Value>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                用于对成员显示名称进行格式化的类名

                <p>已废弃. 使用MemberFormatter项目</p>
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                层级描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="captionColumn" required="false">
            <Doc>
                用于显示成员名称的列名
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Object name="keyExp" type="KeyExpression" required="false">
            <Doc>
                用SQL表达式填充层级的关键字列
            </Doc>
        </Object>
        <Object name="nameExp" type="NameExpression" required="false">
            <Doc>
                用SQL表达式填充层级名称列，如果没有指定会使用keyExp的值
            </Doc>
        </Object>
        <Object name="captionExp" type="CaptionExpression" required="false">
            <Doc>
                用SQL表达式填充层级显示值列，如果没有指定会使用nameExp的值
            </Doc>
        </Object>
        <Object name="ordinalExp" type="OrdinalExpression" required="false">
            <Doc>
                用SQL表达式填充层级排序值列
            </Doc>
        </Object>
        <Object name="parentExp" type="ParentExpression" required="false">
            <Doc>
                用SQL表达式填充层级的父成员值列
            </Doc>
        </Object>
        <Object name="memberFormatter" type="MemberFormatter" required="false">
            <Doc>
                成员格式化
            </Doc>
        </Object>
        <Object name="closure" type="Closure" required="false"/>
        <Array name="properties" type="Property" min="0"/>
        <Code>
            public Expression getKeyExp() {
                if (keyExp != null) {
                    return keyExp;
                } else if (column != null) {
                    return new Column(table, column);
                } else {
                    return null;
                }
            }

            public Expression getNameExp() {
                if (nameExp != null) {
                    return nameExp;
                } else if (nameColumn != null) {
                    return new Column(table, nameColumn);
                } else {
                    return null;
                }
            }

            public Expression getCaptionExp() {
                if (captionExp != null) {
                    return captionExp;
                } else if (captionColumn != null) {
                    return new Column(table, captionColumn);
                } else {
                    return null;
                }
            }

            public Expression getOrdinalExp() {
                if (ordinalExp != null) {
                    return ordinalExp;
                } else if (ordinalColumn != null) {
                    return new Column(table, ordinalColumn);
                } else {
                    return null;
                }
            }

            public Expression getParentExp() {
                if (parentExp != null) {
                    return parentExp;
                } else if (parentColumn != null) {
                    return new Column(table, parentColumn);
                } else {
                    return null;
                }
            }

            public Expression getPropertyExp(int i) {
                return new Column(table, properties[i].column);
            }

            public mondrian.spi.Dialect.Datatype getDatatype() {
                return mondrian.spi.Dialect.Datatype.valueOf(type);
            }
        </Code>
    </Element>

    <Element type="Closure">
        <Doc>
            Specifies the transitive closure of a parent-child hierarchy.
            Optional, but recommended for better performance.
            The closure is provided as a set of (parent/child) pairs:
            since it is the transitive closure these are actually (ancestor/descendant) pairs.
        </Doc>
        <Attribute name="parentColumn" required="true"/>
        <Attribute name="childColumn" required="true"/>
        <Object name="table" type="Table" required="true"/>
    </Element>

    <Element type="Property">
        <Doc>
            成员属性
        </Doc>
        <Attribute name="name"><Doc></Doc></Attribute>
        <Attribute name="column"><Doc></Doc></Attribute>
        <Attribute name="type" default="String">
            <Doc>
                该属性的数据类型
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                <p>格式化类名，用于显示合适的属性</p>

                <p>该类必须实现spi.PropertyFormatter接口</p>

                <p>已废弃。请使用PropertyFormatter</p>
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                成员属性描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="dependsOnLevelValue" required="false" type="Boolean">
            <Doc>
		        如果设置为true，指明该成员属性的值功能上依赖哪个成员属性的Level值，
		        换句话说，对一个给定的level值，属性值是稳定的。
		        这就可以在GROUP BY片段中省略关联的属性列（如果数据库允许列在SELECT中，而不在GROUP BY）。
		        这可以在一些数据库上显著提升性能，例如MySQL
            </Doc>
        </Attribute>
        <Object name="propertyFormatter" type="PropertyFormatter" required="false">
            <Doc>
                属性格式化
            </Doc>
        </Object>
    </Element>

    <Element type="Measure">
        <Attribute name="name" required="true">
            <Doc>度量名称</Doc>
        </Attribute>
        <Attribute name="column" required="false">
            <Doc>
                度量值对应的列
                如果该属性没有被指定，度量表达式(measureExp)必须被指定
            </Doc>
        </Attribute>
        <Attribute name="datatype" required="false">
            <Doc>
                度量的数据类型
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.
                
                <p/>如果度量的聚合函数是'Count'，那么默认数据类型是'Integer'
                否则，为'Numeric'
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="formatString">
            <Doc>
                用于格式化度量单元格的字符串，更多细节参看util.Format类
            </Doc>
        </Attribute>
        <Attribute name="aggregator" required="true">
            <Doc>
                聚合函数。
                允许的值有"sum", "count", "min", "max", "avg", and "distinct-count"
                ("distinct count"允许向后兼容，但是已被废弃，因为XML的DTD中的枚举属性不能包含空格)
            </Doc>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                <p>格式化器类的名称，用于使单元格显示适当的内容</p>

                <p>该类必须实现spi.CellFormatter接口</p>

                <p>该属性已被废弃，请使用近似属性CellFormatter</p>
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                用来替换name属性作为显示名称
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                度量描述
                可以使用#{propertyname}从属性文件中替换
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean" required="false">
            <Doc>
                是否可见，默认为true
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>包含用户自定义属性值</Doc>
        </Object>
        <Object name="measureExp" type="MeasureExpression" required="false">
            <Doc>
                该SQL表达式用于计算度量。
                如果没有指定来源列(column)，则此项为必选
            </Doc>
        </Object>
        <Object name="cellFormatter" type="CellFormatter" required="false">
            <Doc>
                单元格格式化器
            </Doc>
        </Object>
        <Array name="memberProperties" type="CalculatedMemberProperty" min="0"/>
    </Element>

    <Element type="CalculatedMember">
        <Attribute name="name" required="true">
            <Doc>
                计算成员的名称
            </Doc>
        </Attribute>
        <Attribute name="formatString">
            <Doc>
                Format string with which to format cells of this member. For
                more details, see {@link mondrian.util.Format}.
                格式化器类的名称，用于使单元格显示适当的内容
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this calculated member.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="formula" required="false">
            <Doc>
                MDX expression which gives the value of this member.
                Equivalent to the Formula sub-element.
            </Doc>
        </Attribute>
        <Attribute name="dimension" required="false">
            <Doc>
                <p>Name of the dimension that this member belongs to.</p>
                <p>Deprecated: use {@code hierarchy} attribute instead.</p>
            </Doc>
        </Attribute>
        <Attribute name="hierarchy" required="false">
            <Doc>
                <p>Name of the hierarchy that this member belongs to.</p>
            </Doc>
        </Attribute>
        <Attribute name="parent" required="false">
            <Doc>
                Fully-qualified name of the parent member.
                If not specified, the member will be at the lowest level
                (besides the 'all' level) in the hierarchy.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean" required="false">
            <Doc>
                Whether this member is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>Contains values of user-defined properties.</Doc>
        </Object>
        <Object name="formulaElement" type="Formula" required="false">
            <Doc>
                MDX expression which gives the value of this member.
            </Doc>
        </Object>
        <Object name="cellFormatter" type="CellFormatter" required="false">
            <Doc>
                Cell formatter.
            </Doc>
        </Object>
        <Array name="memberProperties" type="CalculatedMemberProperty" min="0"/>
        <Code>
            /**
              * Returns the formula, looking for a sub-element called
              * "Formula" first, then looking for an attribute called
              * "formula".
              */
            public String getFormula() {
                if (formulaElement != null) {
                    return formulaElement.cdata;
                } else {
                    return formula;
                }
            }
            /**
              * Returns the format string, looking for a property called
              * "FORMAT_STRING" first, then looking for an attribute called
              * "formatString".
              */
            public String getFormatString() {
                for (CalculatedMemberProperty prop : memberProperties) {
                    if (prop.name.equals(
                        mondrian.olap.Property.FORMAT_STRING.name))
                    {
                        return prop.value;
                    }
                }
                return formatString;
            }
        </Code>
    </Element>

    <Element type="CalculatedMemberProperty">
        <Doc>
            Property of a calculated member defined against a cube.
            It must have either an expression or a value.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this member property.
            </Doc>
        </Attribute>
         <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the name of this calculated
                member property.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this calculated member property.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="expression">
            <Doc>
                MDX expression which defines the value of this property.
                If the expression is a constant string, you could enclose it in
                quotes, or just specify the 'value' attribute instead.
            </Doc>
        </Attribute>
        <Attribute name="value">
            <Doc>
                Value of this property.
                If the value is not constant, specify the 'expression' attribute
                instead.
            </Doc>
        </Attribute>
    </Element>

    <Element type="NamedSet">
        <Doc><![CDATA[
            <p>Defines a named set which can be used in queries in the
            same way as a set defined using a WITH SET clause.</p>

            <p>A named set can be defined against a particular cube,
            or can be global to a schema. If it is defined against a
            cube, it is only available to queries which use that cube.</p>

            <p>A named set defined against a cube is not inherited by
            a virtual cubes defined against that cube. (But you can
            define a named set against a virtual cube.)</p>

            <p>A named set defined against a schema is available in
            all cubes and virtual cubes in that schema. However, it is
            only valid if the cube contains dimensions with the names
            required to make the formula valid.</p>]]>

        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this named set.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                Caption of this named set.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this named set.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="formula" required="false">
            <Doc>
                MDX expression which gives the value of this set.
                Equivalent to the Formula sub-element.
            </Doc>
        </Attribute>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>Contains values of user-defined properties.</Doc>
        </Object>
        <Object name="formulaElement" type="Formula" required="false">
            <Doc>
                MDX expression which gives the value of this set.
            </Doc>
        </Object>
        <Code>
            /**
              * Returns the formula, looking for a sub-element called
              * "Formula" first, then looking for an attribute called
              * "formula".
              */
            public String getFormula() {
                if (formulaElement != null) {
                    return formulaElement.cdata;
                } else {
                    return formula;
                }
            }
        </Code>
    </Element>

    <Element type="Formula">
        <CData/>
    </Element>

    <Element type="MemberReaderParameter">
        <Doc>Not used</Doc>
        <Attribute name="name"/>
        <Attribute name="value"/>
    </Element>

    <Element type="RelationOrJoin" abstract="true">
        <Doc>A table or a join</Doc>
        <Code>
            public abstract Relation find(String seekAlias);
            public boolean equals(Object o) {
                return this == o;
            }
            public int hashCode() {
                return System.identityHashCode(this);
            }
        </Code>
    </Element>

    <Element type="Relation" class="RelationOrJoin" abstract="true">
        <Doc>A table, inline table or view</Doc>
        <Code>
            public abstract String getAlias();
        </Code>
    </Element>

    <Element type="View" class="Relation">
        <Doc>
            A collection of SQL statements, one per dialect.
        </Doc>
        <Attribute name="alias" required="true"/>
        <Array name="selects" type="SQL" min="1"/>
        <Code>
            /**
             * Copy constructor.
             */
            public View(View view) {
                this.alias = view.alias;
                this.selects = view.selects.clone();
            }
            public String toString() {
                return selects[0].cdata;
            }

            public View find(String seekAlias) {
                if (seekAlias.equals(alias)) {
                    return this;
                } else {
                    return null;
                }
            }

            public String getAlias() {
                return alias;
            }

            public SqlQuery.CodeSet getCodeSet() {
                return SQL.toCodeSet(selects);
            }

            public void addCode(String dialect, String code) {
                if (selects == null) {
                    selects = new SQL[1];
                } else {
                    SQL[] olds = selects;
                    selects = new SQL[olds.length + 1];
                    System.arraycopy(olds, 0, selects, 0, olds.length);
                }
                SQL sql = new SQL();
                sql.dialect = dialect;
                sql.cdata = code;
                selects[selects.length - 1] = sql;
            }

            public boolean equals(Object o) {
                if (o instanceof View) {
                    View that = (View) o;
                    if (!this.alias.equals(that.alias)) {
                        return false;
                    }
                    if (this.selects == null || that.selects == null || this.selects.length != that.selects.length) {
                        return false;
                    }
                    for (int i = 0; i &lt; selects.length; i++) {
                        if (!Util.equals(this.selects[i].dialect, that.selects[i].dialect)
                            || !Util.equals(this.selects[i].cdata, that.selects[i].cdata))
                        {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
            </Code>
    </Element>

    <Element type="SQL">
        <Attribute name="dialect" required="true" default="generic">
            <Doc>
                Dialect of SQL the view is intended for. Valid values include,
                but are not limited to:
                <ul>
                <li>generic</li>
                <li>access</li>
                <li>db2</li>
                <li>derby</li>
                <li>firebird</li>
                <li>hsqldb</li>
                <li>mssql</li>
                <li>mysql</li>
                <li>oracle</li>
                <li>postgres</li>
                <li>sybase</li>
                <li>teradata</li>
                <li>ingres</li>
                <li>infobright</li>
                <li>luciddb</li>
                <li>vertica</li>
                <li>neoview</li>
                </ul>
            </Doc>
        </Attribute>
        <CData/>
        <Code><![CDATA[
            public int hashCode() {
                return dialect.hashCode();
            }

            public boolean equals(Object obj) {
                if (!(obj instanceof SQL)) {
                    return false;
                }
                SQL that = (SQL) obj;
                return this.dialect.equals(that.dialect) &&
                        Util.equals(this.cdata, that.cdata);
            }

            /**
             * Converts an array of SQL to a
             * {@link mondrian.rolap.sql.SqlQuery.CodeSet} object.
             */
            public static SqlQuery.CodeSet toCodeSet(SQL[] sqls) {
                SqlQuery.CodeSet codeSet = new SqlQuery.CodeSet();
                for (SQL sql : sqls) {
                    codeSet.put(sql.dialect, sql.cdata);
                }
                return codeSet;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Join" class="RelationOrJoin">
        <Attribute name="leftAlias">
            <Doc>
                Defaults to left's alias if left is a table, otherwise
                required.
            </Doc>
        </Attribute>
        <Attribute name="leftKey" required="true"/>
        <Attribute name="rightAlias">
            <Doc>
                Defaults to right's alias if right is a table, otherwise
                required.
            </Doc>
        </Attribute>
        <Attribute name="rightKey" required="true"/>
        <Object name="left" type="RelationOrJoin" required="true"/>
        <Object name="right" type="RelationOrJoin" required="true"/>
        <Code>
            /** Convenience constructor. */
            public Join(
                String leftAlias,
                String leftKey,
                RelationOrJoin left,
                String rightAlias, 
                String rightKey,
                RelationOrJoin right)
            {
                this.leftAlias = leftAlias;
                this.leftKey = leftKey;
                this.left = left;
                this.rightAlias = rightAlias;
                this.rightKey = rightKey;
                this.right = right;
            }
            /**
              * Returns the alias of the left join key, defaulting to left's
              * alias if left is a table.
              */
            public String getLeftAlias() {
                if (leftAlias != null) {
                    return leftAlias;
                }
                if (left instanceof Relation) {
                    return ((Relation) left).getAlias();
                }
                throw Util.newInternal(
                    "alias is required because " + left + " is not a table");
            }
            /**
              * Returns the alias of the right join key, defaulting to right's
              * alias if right is a table.
              */
            public String getRightAlias() {
                if (rightAlias != null) {
                    return rightAlias;
                }
                if (right instanceof Relation) {
                    return ((Relation) right).getAlias();
                }
                if (right instanceof Join) {
                    return ((Join) right).getLeftAlias();
                }
                throw Util.newInternal(
                    "alias is required because " + right + " is not a table");
            }
            public String toString() {
                return "(" + left + ") join (" + right + ") on " +
                    leftAlias + "." + leftKey + " = " +
                    rightAlias + "." + rightKey;
            }
            public Relation find(String seekAlias) {
                Relation relation = left.find(seekAlias);
                if (relation == null) {
                    relation = right.find(seekAlias);
                }
                return relation;
            }
        </Code>
    </Element>

    <Element type="Table" class="Relation">
        <Attribute name="name" required="true"/>
        <Attribute name="schema">
            <Doc>
                Optional qualifier for <code>table</code>.
            </Doc>
        </Attribute>
        <Attribute name="alias">
            <Doc>
                Alias to be used with this table when it is used to
                form queries. If not specified, defaults to the table
                name, but in any case, must be unique within the
                schema. (You can use the same table in different
                hierarchies, but it must have different aliases.)
            </Doc>
        </Attribute>
        <Object name="filter" type="SQL" required="false">
        <Doc>
          The SQL WHERE clause expression to be appended to any select statement
        </Doc>
        </Object>
        <Array name="aggExcludes" type="AggExclude" required="false"/>
        <Array name="aggTables" type="AggTable" required="false"/>
        <Array name="tableHints" type="Hint" required="false">
            <Doc>
                Table optimization hints; may be ignored by dialect.
            </Doc>
        </Array>

        <Code><![CDATA[
            private java.util.Map<String,String> hintMap;
            /** Convenience constructor. */
            public Table(Table table) {
                this(table.schema, table.name, table.alias, table.tableHints);
            }
            public Table(String schema, String name, String alias, Hint[] tablehints) {
                this();
                this.schema = schema;
                this.name = name;
                this.alias = alias;
                this.hintMap = buildHintMap(tablehints);
            }

            public Table(Table tbl, String possibleName) {
                this(tbl.schema, tbl.name, possibleName, tbl.tableHints);
                
                // Remake the filter with the new alias
                if (tbl.filter != null) {
                    this.filter = new SQL();
                    this.filter.dialect = tbl.filter.dialect;
                     if (tbl.filter.cdata != null) {
                        this.filter.cdata =
                            tbl.filter.cdata.replace(
                                tbl.alias == null
                                    ? tbl.name
                                    : tbl.alias,
                                possibleName);
                    }
                }
            }
            
            private java.util.Map<String,String> buildHintMap(Hint[] th) {
                java.util.Map<String,String> h =
                    new java.util.HashMap<String,String>();
                if (th != null) {
                    for (int i = 0; i < th.length; i++) {
                        h.put(th[i].type, th[i].cdata);
                    }
                }
                return h;
            }
            /** Returns the alias or, if it is null, the table name. */
            public String getAlias() {
                return (alias != null) ? alias : name;
            }
            public String toString() {
                return (schema == null) ?
                    name :
                    schema + "." + name;
            }
            public Table find(String seekAlias) {
                return seekAlias.equals(name) ? this :
                    (alias != null) && seekAlias.equals(alias) ? this :
                    null;
            }
            public boolean equals(Object o) {
                if (o instanceof Table) {
                    Table that = (Table) o;
                    return this.name.equals(that.name) &&
                        Util.equals(this.alias, that.alias) &&
                        Util.equals(this.schema, that.schema);
                } else {
                    return false;
                }
            }
            public int hashCode() {
                return toString().hashCode();
            }
            public String getFilter() {
                return (filter == null) ? null : filter.cdata;
            }
            public AggExclude[] getAggExcludes() {
                return aggExcludes;
            }
            public AggTable[] getAggTables() {
                return aggTables;
            }
            public java.util.Map<String,String> getHintMap() {
                if (hintMap == null) {
                    hintMap = buildHintMap(this.tableHints);
                }
                return hintMap;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Hint">
        <Doc>
            Dialect-specific table optimization hints.
        </Doc>
        <Attribute name="type" required="true">
            <Doc>
                Type of hint, interpreted and applied on a per-dialect basis.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <Element type="InlineTable" class="Relation">
        <Attribute name="alias">
            <Doc>
                Alias to be used with this table when it is used to
                form queries. If not specified, defaults to the table
                name, but in any case, must be unique within the
                schema. (You can use the same table in different
                hierarchies, but it must have different aliases.)
            </Doc>
        </Attribute>
        <Object name="columnDefs" type="ColumnDefs" required="true"/>
        <Object name="rows" type="Rows" required="true"/>
        <Code><![CDATA[
            /** Convenience constructor. */
            public InlineTable(InlineTable inlineTable) {
                this.alias = inlineTable.alias;
                this.columnDefs = new ColumnDefs();
                this.columnDefs.array = inlineTable.columnDefs.array.clone();
                this.rows = new Rows();
                this.rows.array = inlineTable.rows.array.clone();
            }
            public String getAlias() {
                return alias;
            }
            public String toString() {
                return "<inline data>";
            }
            public InlineTable find(String seekAlias) {
                return seekAlias.equals(this.alias) ? this : null;
            }
            public boolean equals(Object o) {
                if (o instanceof InlineTable) {
                    InlineTable that = (InlineTable) o;
                    return this.alias.equals(that.alias);
                } else {
                    return false;
                }
            }
            public int hashCode() {
                return toString().hashCode();
            }
            ]]>
        </Code>
    </Element>

    <Element type="ColumnDefs">
        <Doc>Holder for an array of ColumnDef elements</Doc>
        <Array name="array" type="ColumnDef"/>
    </Element>

    <Element type="ColumnDef">
        <Doc>
            Column definition for an inline table.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <Attribute name="type" required="true">
            <Doc>
                Type of the column:
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
    </Element>

    <Element type="Rows">
        <Doc>Holder for an array of Row elements</Doc>
        <Array name="array" type="Row"/>
    </Element>

    <Element type="Row">
        <Doc>
            Row definition for an inline table.
            Must have one Column for each ColumnDef in the InlineTable.
        </Doc>
        <Array name="values" type="Value"/>
    </Element>

    <Element type="Value">
        <Doc>
            Column value for an inline table.
            The CDATA holds the value of the column.
        </Doc>
        <Attribute name="column" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <!-- AggTable ======================================================= -->
    <Element type="AggTable" abstract="true">
        <Doc>
            A definition of an aggregate table for a base fact table.
            This aggregate table must be in the same schema as the
            base fact table.
        </Doc>
        <Attribute name="ignorecase" type="Boolean" required="false"
                default="true" >
            <Doc>
                Whether or not the match should ignore case.
            </Doc>
        </Attribute>
        <Object name="factcount" type="AggFactCount" required="true">
            <Doc>
                What does the fact_count column look like.
            </Doc>
        </Object>
        <Array name="ignoreColumns" type="AggIgnoreColumn"/>
        <Array name="foreignKeys" type="AggForeignKey"/>
        <Array name="measures" type="AggMeasure"/>
        <Array name="levels" type="AggLevel"/>
        <Code>
            public boolean isIgnoreCase() {
                return ignorecase.booleanValue();
            }
            public AggFactCount getAggFactCount() {
                return factcount;
            }
            public AggIgnoreColumn[] getAggIgnoreColumns() {
                return ignoreColumns;
            }
            public AggForeignKey[] getAggForeignKeys() {
                return foreignKeys;
            }
            public AggMeasure[] getAggMeasures() {
                return measures;
            }
            public AggLevel[] getAggLevels() {
                return levels;
            }
        </Code>
    </Element>

    <Element type="AggName" class="AggTable">
        <Attribute name="name" required="true">
            <Doc>
                The Table name of a Specific aggregate table.
            </Doc>
        </Attribute>
        <Attribute name="approxRowCount" required="false">
            <Doc>
                The estimated number of rows in this aggregation
                table. Setting this property improves the
                performance of the aggregation optimizer and
                prevents it from issuing a 'select count(*)'
                query over the aggregation table.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getApproxRowCountAttribute() {
                return approxRowCount;
            }
        </Code>
    </Element>

    <Element type="AggPattern" class="AggTable">
        <Attribute name="pattern" required="true">
            <Doc>
                A Table pattern used to define a set of aggregate tables.
            </Doc>
        </Attribute>
        <Array name="excludes" type="AggExclude"/>
        <Code>
            public String getPattern() {
                return pattern;
            }
            public AggExclude[] getAggExcludes() {
                return excludes;
            }
        </Code>
    </Element>

    <Element type="AggExclude">
        <Attribute name="pattern" required="false">
            <Doc>
                A Table pattern not to be matched.
            </Doc>
        </Attribute>
        <Attribute name="name" required="false">
            <Doc>
                The Table name not to be matched.
            </Doc>
        </Attribute>
        <Attribute name="ignorecase" type="Boolean" required="false"
                default="true" >
            <Doc>
                Whether or not the match should ignore case.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getPattern() {
                return pattern;
            }
            public boolean isIgnoreCase() {
                return ignorecase.booleanValue();
            }
        </Code>
    </Element>

    <Element type="AggColumnName" abstract="true">
        <Attribute name="column" required="true">
            <Doc>
                The name of the fact count column.
            </Doc>
        </Attribute>
        <Code>
            public String getColumnName() {
                return column;
            }
        </Code>
    </Element>

    <Element type="AggFactCount" class= "AggColumnName"/>

    <Element type="AggIgnoreColumn" class= "AggColumnName"/>

    <Element type="AggForeignKey">
        <Doc>
            The name of the column mapping from base fact table foreign key
            to aggregate table foreign key.
        </Doc>
        <Attribute name="factColumn" required="true">
            <Doc>
                The name of the base fact table foreign key.
            </Doc>
        </Attribute>
        <Attribute name="aggColumn" required="true">
            <Doc>
                The name of the aggregate table foreign key.
            </Doc>
        </Attribute>
        <Code>
            public String getFactFKColumnName() {
                return factColumn;
            }
            public String getAggregateFKColumnName() {
                return aggColumn;
            }
        </Code>
    </Element>
    <Element type="AggLevel">
        <Attribute name="column" required="true">
            <Doc>
                The name of the column mapping to the level name.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                The name of the Dimension Hierarchy level.
            </Doc>
        </Attribute>
        <Attribute name="collapsed" required="false" type="Boolean" default="true">
            <Doc>
                Whether this is a collapsed level. The parents of that level
                are also present in the aggregation table.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getColumnName() {
                return column;
            }
            public boolean isCollapsed() {
                return collapsed;
            }
        </Code>
    </Element>

    <Element type="AggMeasure">
        <Attribute name="column" required="true">
            <Doc>
                The name of the column mapping to the measure name.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                The name of the Cube measure.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getColumn() {
                return column;
            }
        </Code>
    </Element>


    <Class class="Expression">
        <Code>
            public abstract String getExpression(SqlQuery query);
            public abstract String getGenericExpression();
            public abstract String getTableAlias();
        </Code>
    </Class>

    <Element type="Column" class="Expression">
        <Attribute name="table">
            <Doc>
                Alias of the table which contains this column. Not required if
                the query only has one table.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <Code><![CDATA[
            private String genericExpression;

            /** Convenience constructor. */
            public Column(String table, String name) {
                this();
                Util.assertTrue(name != null);
                this.table = table;
                this.name = name;
                this.genericExpression = table == null ? name : (table + "." + name);
            }

            public String getExpression(SqlQuery query) {
                return query.getDialect().quoteIdentifier(table, name);
            }

            public String getGenericExpression() {
                return genericExpression;
            }

            public String getColumnName() {
                return name;
            }
            public String getTableAlias() {
                return table;
            }
            public int hashCode() {
                return name.hashCode() ^ (table==null ? 0 : table.hashCode());
            }

            public boolean equals(Object obj) {
                if (!(obj instanceof Column)) {
                    return false;
                }
                Column that = (Column) obj;
                return this.name.equals(that.name) &&
                        Util.equals(this.table, that.table);
            }]]>
        </Code>
    </Element>

    <Element type="ExpressionView" class="Expression" abstract="true">
        <Doc>
            A collection of SQL expressions, one per dialect.
        </Doc>
        <Array name="expressions" type="SQL" min="1"/>
        <Code><![CDATA[
            public String toString() {
                return expressions[0].cdata;
            }

            public String getExpression(SqlQuery query) {
                return SQL.toCodeSet(expressions).chooseQuery(query.getDialect());
            }

            public String getGenericExpression() {
                for (int i = 0; i < expressions.length; i++) {
                    if (expressions[i].dialect.equals("generic")) {
                        return expressions[i].cdata;
                    }
                }
                return expressions[0].cdata;
            }

            public String getTableAlias() {
                return null;
            }

            public int hashCode() {
                int h = 17;
                for (int i = 0; i < expressions.length; i++) {
                    h = 37 * h + expressions[i].hashCode();
                }
                return h;
            }

            public boolean equals(Object obj) {
                if (!(obj instanceof ExpressionView)) {
                    return false;
                }
                ExpressionView that = (ExpressionView) obj;
                if (this.expressions.length != that.expressions.length) {
                    return false;
                }
                for (int i = 0; i < expressions.length; i++) {
                    if (! this.expressions[i].equals(that.expressions[i])) {
                        return false;
                    }
                }
                return true;
            }
            ]]>
        </Code>
    </Element>

    <Element type="KeyExpression" class="ExpressionView"/>
    <Element type="ParentExpression" class="ExpressionView"/>
    <Element type="OrdinalExpression" class="ExpressionView"/>
    <Element type="NameExpression" class="ExpressionView"/>
    <Element type="CaptionExpression" class="ExpressionView"/>
    <Element type="MeasureExpression" class="ExpressionView"/>

    <!-- Access control =================================================== -->
    <Element type="Role">
        <Doc>
            A role defines an access-control profile. It has a series of grants
            (or denials) for schema elements.
        </Doc>
        <Attribute name="name" required="true"/>
        <Object name="annotations" type="Annotations" required="false">
            <Doc>Contains values of user-defined properties.</Doc>
        </Object>
        <Array name="schemaGrants" type="SchemaGrant"/>
        <Object name="union" type="Union" required="false" />
    </Element>

    <Class class="Grant">
        <Attribute name="access" required="true">
            <Doc>Values correspond to <code>Access</code>.</Doc>
            <Value>all</Value>
            <Value>custom</Value>
            <Value>none</Value>
            <Value>all_dimensions</Value>
        </Attribute>
    </Class>

    <Element class="Grant" type="SchemaGrant">
        <Doc>
            Grants (or denies) this role access to this schema.
            <code>access</code> may be "all", "all_dimensions", "custom"
            or "none".
            If <code>access</code> is "all_dimensions", the role has access
            to all dimensions but still needs explicit access to cubes.
            If <code>access</code> is "custom", no access will be inherited by
            cubes for which no explicit rule is set.
            If <code>access</code> is "all_dimensions", an implicut access is
            given to all dimensions of the schema's cubes, provided the cube's
            access attribute is either "custom" or "all".
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Schema, int)">mondrian.olap.Role#grant(mondrian.olap.Schema,int)</a>.
        </Doc>
        <Array name="cubeGrants" type="CubeGrant"/>
    </Element>

    <Element class="Grant" type="CubeGrant">
        <Doc>
            Grants (or denies) this role access to a cube.
            <code>access</code> may be "all", "custom", or "none".
            If <code>access</code> is "custom", no access will be inherited
            by the dimensions of this cube, unless the parent SchemaGrant is
            set to "ALL_DIMENSIONS".
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Cube, int)">mondrian.olap.Role#grant(mondrian.olap.Cube,int)</a>.
        </Doc>
        <Attribute name="cube" required="true">
            <Doc>The unique name of the cube</Doc>
        </Attribute>
        <Array name="dimensionGrants" type="DimensionGrant"/>
        <Array name="hierarchyGrants" type="HierarchyGrant"/>
    </Element>

    <Element class="Grant" type="DimensionGrant">
        <Doc>
            Grants (or denies) this role access to a dimension.
            <code>access</code> may be "all", "custom" or "none".
            Note that a role is implicitly given access to a dimension when it
            is given "ALL" acess to a cube.
            If <code>access</code> is "custom", no access will be inherited
            by the hierarchies of this dimension.
            If the parent schema <code>access</code> is "ALL_DIMENSIONS",
            this timension will inherit <code>access</code> "ALL".
            See also the "all_dimensions" option of the "SchemaGrant" element.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Dimension, int)">mondrian.olap.Role#grant(mondrian.olap.Dimension,int)</a>.
        </Doc>
        <Attribute name="dimension" required="true">
            <Doc>The unique name of the dimension</Doc>
        </Attribute>
    </Element>

    <Element class="Grant" type="HierarchyGrant">
        <Doc>
            Grants (or denies) this role access to a hierarchy.
            <code>access</code> may be "all", "custom" or "none".
            If <code>access</code> is "custom", you may also specify the
            attributes <code>topLevel</code>, <code>bottomLevel</code>, and
            the member grants.
            If <code>access</code> is "custom", the child levels of this
            hierarchy will not inherit access rights from this hierarchy,
            should there be no explicit rules defined for the said child level.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Hierarchy, int, mondrian.olap.Level)">mondrian.olap.Role#grant(mondrian.olap.Hierarchy, int, mondrian.olap.Level)</a>.
        </Doc>
        <Attribute name="hierarchy" required="true">
            <Doc>The unique name of the hierarchy</Doc>
        </Attribute>
        <Attribute name="topLevel" required="false">
            <Doc>Unique name of the highest level of the hierarchy from which
            this role is allowed to see members. May only be specified if
            the <code>HierarchyGrant.access</code> is "custom". If not
            specified, role can see members up to the top level.</Doc>
        </Attribute>
        <Attribute name="bottomLevel" required="false">
            <Doc>Unique name of the lowest level of the hierarchy from which
            this role is allowed to see members. May only be specified if
            the <code>HierarchyGrant.access</code> is "custom". If not
            specified, role can see members down to the leaf level.</Doc>
        </Attribute>
        <Attribute name="rollupPolicy" required="false">
            <Doc>Policy which determines how cell values are calculated if
                not all of the children of the current cell are visible to
                the current role. Allowable values are 'full' (the default),
                'partial', and 'hidden'.</Doc>
        </Attribute>
        <Array name="memberGrants" type="MemberGrant"/>
    </Element>

    <Element type="MemberGrant">
        <Doc>
            Grants (or denies) this role access to a member.
            The children of this member inherit that access.
            You can implicitly see a member if you can see any of its children.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Member, int)">mondrian.olap.Role#grant(mondrian.olap.Member,int)</a>.
        </Doc>
        <Attribute name="member" required="true">
            <Doc>The unique name of the member</Doc>
        </Attribute>
        <Attribute name="access" required="true">
            <Value>all</Value>
            <Value>none</Value>
        </Attribute>
    </Element>

    <!-- Union ============================================================ -->
    <Element type="Union">
        <Doc>
            Body of a Role definition which defines a Role to be the union
            of several Roles. The RoleUsage elements must refer to Roles that
            have been declared earlier in this schema file.
        </Doc>
        <Array name="roleUsages" type="RoleUsage" required="true"/>
    </Element>

    <!-- RoleUsage ======================================================== -->
    <Element type="RoleUsage">
        <Doc>
            Usage of a Role in a union Role.
        </Doc>
        <Attribute name="roleName" required="true"/>
    </Element>

    <!-- UserDefinedFunction ============================================== -->
    <Element type="UserDefinedFunction">
        <Doc>
            A <code>UserDefinedFunction</code> is a function which
            extends the MDX language. It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/UserDefinedFunction.html">mondrian.spi.UserDefinedFunction</a>.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>Name with which the user-defined function will be referenced in MDX expressions.</Doc>
        </Attribute>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this user-defined function.
                Must implement the <code>mondrian.spi.UserDefinedFunction</code>
                interface.
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this user-defined function.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="Parameter">
        <Doc>
            A <code>Parameter</code> defines a schema parameter.
            It can be referenced from an MDX statement using the <code>ParamRef</code>
            function and, if not final, its value can be overridden.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this parameter.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this parameter.
            </Doc>
        </Attribute>
        <Attribute name="type" default="String" required="true">
            <Doc>
                Indicates the type of this parameter:
                String, Numeric, Integer, Boolean, Date, Time, Timestamp, or Member.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
            <Value>Member</Value>
        </Attribute>
        <Attribute name="modifiable" type="Boolean" required="false" default="true">
            <Doc>
                If false, statement cannot change the value of this parameter;
                the parameter becomes effectively constant (provided that its default
                value expression always returns the same value).
                Default is true.
            </Doc>
        </Attribute>
        <Attribute name="defaultValue" type="String" required="false">
            <Doc>
                Expression for the default value of this parameter.
            </Doc>
        </Attribute>
    </Element>

    <Element type="Annotations">
        <Doc>Holder for an array of Annotation elements</Doc>
        <Array name="array" type="Annotation"/>
    </Element>

    <Element type="Annotation">
        <Doc>
            User-defined property value.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of the annotation.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <Element type="Script">
        <Doc>
            Script fragment to implement an SPI such as user-defined function,
            member formatter, cell formatter.
        </Doc>
        <Attribute name="language" required="false" default="JavaScript">
            <Doc>
                The language of the script. Must be a supported scripting
                language in the current JVM. See
                {@link javax.script.ScriptEngineManager}.
                Default value is 'JavaScript'.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <Element type="CellFormatter">
        <Doc>
            Plugin that formats the values of cells.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/CellFormatter.html">mondrian.spi.CellFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this cell formatter.
                Must implement the <code>mondrian.spi.CellFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this cell formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="MemberFormatter">
        <Doc>
            Plugin that formats members.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/MemberFormatter.html">mondrian.spi.MemberFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this member formatter.
                Must implement the <code>mondrian.spi.MemberFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this member formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="PropertyFormatter">
        <Doc>
            Plugin that formats properties.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/PropertyFormatter.html">mondrian.spi.PropertyFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this property formatter.
                Must implement the <code>mondrian.spi.PropertyFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this property formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>
</Model>

<!-- End Mondrian.xml -->
